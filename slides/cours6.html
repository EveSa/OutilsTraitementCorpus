---
layout: presentation
title: Cours6
---
# Outils de Traitement de Corpus
cours 6
-vertical-

# Rappel du cours pr√©c√©dent

<h2 class="r-fit-text">üìèM√©triques d'√©valuationüìè</h2>
<h2 class="r-fit-text">üîºSignificativit√© des r√©sultats‚è´</h2>

-vertical-

# Cours 6

<h2 class="r-fit-text">ü§óPartager ses r√©sultatsü§ó</h2>
<h2 class="r-fit-text"></h2>

-horizontal-

<h2 class="r-fit-text">ü§óPartager ses r√©sultatsü§ó</h2>

-vertical-

Dans le cours 3, on a vu la biblioth√®que `datasets` qui permet de charger des corpus de qualit√© directement depuis le *hub* de HuggingFace.

Maintenant qu'on a constitu√© notre propre corpus, on peut nous aussi le partager sur cette plateforme pour que d'autres personnes puissent utiliser notre travail.

-vertical-

On veut donner toutes les informations que l'on a collect√© √† propos de notre corpus aux personnes qui l'utiliseront :

pour √ßa on va renseigner la carte de notre corpus a.k.a. la *dataset card*

-vertical-

## Les cartes des datasets

Les cartes des corpus sont des fichiers YAML

-horizontal-

‚ùì Des questions ‚ùì

üí° Des id√©es üí°

-vertical-

<h2 class="r-fit-text">Le point bonne pratique &rarr; Les _linters_ de code</h2>

Un _linter_ est une implementation de r√®gles de code qui permet de v√©rifier automatiquement la qualit√© de votre code.

En python, les r√®gles de code sont d√©finies par la PEP (Python Extension Proposal) dont on a d√©j√† beaucoup parl√©.

Maintenant, les IDE embarquent des _linters_ directement dans leur interface ce qui leur permet de vous indiquer quand une variable est mal nomm√©e par exemple.

-vertical-

On distingue deux types de _linters_ :

- les _linters_ logiques &rarr; qui corrigent les erreurs de code
- les _linters_ stylistiques &rarr; qui corrigent le code qui ne se conforme pas √† la PEP

    <table class="table table-hover">
    <thead>
    <tr>
    <th>Linter</th>
    <th>Category</th>
    <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td><a href="https://www.pylint.org/">Pylint</a></td>
    <td>Logical &amp; Stylistic</td>
    <td>Checks for errors, tries to enforce a coding standard, looks for code smells</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/pyflakes">PyFlakes</a></td>
    <td>Logical</td>
    <td>Analyzes programs and detects various errors</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/pycodestyle">pycodestyle</a></td>
    <td>Stylistic</td>
    <td>Checks against some of the style conventions in PEP 8</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/pydocstyle">pydocstyle</a></td>
    <td>Stylistic</td>
    <td>Checks compliance with Python docstring conventions</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/bandit">Bandit</a></td>
    <td>Logical</td>
    <td>Analyzes code to find common security issues</td>
    </tr>
    <tr>
    <td><a href="http://mypy-lang.org/">MyPy</a></td>
    <td>Logical</td>
    <td>Checks for optionally-enforced static types</td>
    </tr>
    </tbody>
    </table>

-vertical-

Pour aller plus loin, on peut utiliser les _formatters_

Des outils tr√®s utiles pour obtenir du code propre

&rarr; Ils appliquent les conseils des _linters_ directement sur votre code.

On utilise majoritairement `black` pour le formattage de code

et `isort` pour le tri des paquets

ÃÄ``ÃÄÃÄÃÄ 
pip install black
black src/*
`ÃÄÃÄÃÄ ÃÄ 

```
pip install isort
python -m isort src/*
```

-vertical-

Pour aller *encore* plus loin :

Si vous ne voulez pas vous emb√™ter √† lancer les commandes `black` et `isort` √† chaque fois que vous faites une modification de votre code (et c'est un bon reflexe : la qualit√© premi√®re de l'informaticien, c'est la flemme !)

Vous pouvez mettre en place un processus automatis√© : 
- avant de commit votre code &rarr; avec des _hooks_
- au moment de tester votre code &rarr; avec l'int√©gration continue (CI)

-vertical-

### Les _hooks_

Les _hooks_ sont des programmes qui se lancent automatiquement √† des moments sp√©cifiques de l'execution de `git`

On peut lancer des programmes √† pleins de moments diff√©rents :
- au moment du commit : `pre-commit`
- pour v√©rifier le format de votre message de commit : `prepare-commit-msg`
- pre-push , ... √† chaque action en fait !

Mettre des [hooks](https://git-scm.com/docs/githooks) en place, c'est tr√®s simple :

On a deux m√©thodes

1. La plus simple : passer par le paquet `pre-commit` et √©crire un fichier YAML de configuration

```
pip install pre-commit 

2. La plus propre : Aller modifier le fichier `pre-commit` qu'il y a d√©j√† dans votre repo `.git/hooks`

-vertical-

1. dans le dossier `hooks` de votre _repo_ git
2. cr√©er un programme executable que vous nommez du nom du hook (`pre-commit` par exemple) avec les commandes que vous voulez faire passer pour votre hook
3. Le rendre executable avec `chmod +x` si n√©cessaire

```
#!/bin/sh

# On r√©cup√®re les fichiers que l'on veut traiter
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep ".jsx\{0,1\}$")

if [[ "$STAGED_FILES" = "" ]]; then
  exit 0
fi

PASS=true

echo "\nlinting:\n"

# Check for black
which black &> /dev/null
if [[ "$?" == 1 ]]; then
  echo "\t\033[41mPlease install black\033[0m"
  exit 1
fi

# Check for isort
which isort &> /dev/null
if [[ "$?" == 1 ]]; then
  echo "\t\033[41mPlease install isort\033[0m"
  exit 1
fi

for FILE in $STAGED_FILES
do
  black "$FILE"
  isort "$FILE"

  if [[ "$?" == 0 ]]; then
    echo "\t\033[32mLinting Passed: $FILE\033[0m"
  else
    echo "\t\033[41mLinting Failed: $FILE\033[0m"
    PASS=false
  fi
done

echo "\nValidation completed!\n"

if ! $PASS; then
  echo "\033[41mCOMMIT FAILED:\033[0m Your commit contains files that should pass black and isort but do not. Please fix the black errors and try again.\n"
  exit 1
else
  echo "\033[42mCOMMIT SUCCEEDED\033[0m\n"
fi

exit $?
``ÃÄ 



-vertical-

Des ressources pour les bonnes pratiques de python :
- https://realpython.com/python-code-quality/
- https://realpython.com/python-pep8/



-vertical-

1. Faire la carte de son Dataset
2. Le publier sur huggingFace

N'oubliez pas pour l'√©valuation de votre repo, je vais surtout regarder si vous vous en √™tes tenus aux points bonnes pratiques
- une bonne organisation de votre r√©pertoire de travail
- les commit conventionnels
- les docstrings
- les conventions de nommage
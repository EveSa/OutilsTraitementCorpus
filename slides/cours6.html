---
layout: presentation
title: Cours6
---
# Outils de Traitement de Corpus
cours 6
-vertical-

# Rappel du cours pr√©c√©dent

<h2 class="r-fit-text">üìèM√©triques d'√©valuationüìè</h2>
<h2 class="r-fit-text">üîºSignificativit√© des r√©sultats‚è´</h2>

-vertical-

# Cours 6

<h2 class="r-fit-text">D√©couper son corpus</h2>
<h2 class="r-fit-text">ü§óPartager ses r√©sultatsü§ó</h2>

-horizontal-

<h2 class="r-fit-text">D√©couper son corpus</h2>

Vous savez qu'il est n√©cessaire de d√©couper son corpus en _train_, _test_ et parfois _dev_ (aussi appel√© _validation_)

&rarr; Est-ce que vous vous rappelez de pourquoi ?

-vertical-

### Pourquoi on d√©coupe les corpus ?

Les mod√®les de Machine Learning et Deep Learning apprennent des r√®gles pour pr√©dire des comportements sur les donn√©es d'un corpus.

&rarr; ces donn√©es deviennent leur r√©alit√©.

Pour √™tre s√ªr.e.s qu'un mod√®le n'a pas simplement appris par coeur √† pr√©dire le corpus de donn√©es qu'on lui a donn√© pour apprendre,  on veut le confronter √† un autre jeu de donn√©es. C'est sur ces donn√©es l√† qu'on va appliquer les m√©triques d'√©valuation (les m√™mes que celles qu'on a appliqu√©es √† notre corpus mais pour notre mod√®le cette fois) : c'est la partition de _test_.

-vertical-

On a donc:
- La partition sur laquelle les mod√®les apprennent : la partition de _train_
- la partition sur lequelle on v√©rifie que le mod√®le g√©n√©ralise bien : la partition de _test_
- et la partition de _dev_

-vertical-

### A quoi sert la partition de _dev_ ?

<div class="fragment">
  Parfois, on a pas un mod√®le qui fonctionne du premier coup :
  
  il a sur-appris les donn√©es du _train_ et on s'en rend compte quand on passe sur le _test_ ...

  Alors on change un peu les param√®tres et on recommence...
</div>

<div class="fragment">
  ‚ö†Ô∏è Si on fait √ßa, on tue le principe de la partition <i>test</i> : on va utiliser le <i>test</i> pour affiner les r√®glages de notre mod√®le et on ne va plus savoir s'il g√©n√©ralise bien sur des donn√©es nouvelles !
</div>

-vertical-

### A quoi sert la partition de _dev_ ?

C'est donc tout l'objectif de la partition _dev_.

On va l'utiliser pour v√©rifier que notre mod√®le est op√©rationnel sur des donn√©es sur lesquels il n'a pas appris

Mais on va aussi pouvoir l'utiliser pour affiner certains param√®tres et am√©liorer les r√©sultats avec plusieurs it√©rations de traitements.

-vertical-

### Comment d√©couper son corpus ?

Comme d'habitude, on se souvient que les mod√®les ont besoin d'√©norm√©ment de donn√©es pour leur entrainement. On va donc vouloir garder une majorit√© des donn√©es pour l'entra√Ænement. Il faut toutefois avoir un √©chantillon repr√©sentatif des donn√©es pour l'√©valuation.

Par d√©faut, on donne 70% du corpus pour l'entrainement et 30% pour la validation.

-vertical-

### Comment d√©couper son corpus ?

Des libraires adapt√©es au ML ou au DL donnent des outils pour d√©couper les corpus.

On peut noter `scikit-learn` qu'on a d√©j√† utilis√© pour l'augmentation de donn√©es la semaine derni√®re

```
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.05, random_state=0)
```

-vertical-

`Datasets` permet √©galement de d√©couper son corpus avec la m√©thode [`train_test_split`](https://huggingface.co/docs/datasets/v2.4.0/en/package_reference/main_classes#datasets.Dataset.train_test_split)

ÃÄ ``
dataset.train_test_split(test_size=0.1)
```

-vertical-

### Les param√®tres des fonctions de _split_

Les fonctions de _split_ ont de nombreux param√®tres comme on peut le voir dans la doc.

- _shuffle_ : (par d√©fault √† _True_) m√©lange les entr√©es de notre corpus
  - &rarr; Pourquoi c'est important ? Lorsqu'on a effectu√© notre nettoyage sur le corpus, on est pass√© par des √©tapes de tris : si notre corpus est toujours tri√© on va avoir un corpus de train et de test tr√®s mal √©quilibr√©

-vertical-

- _stratify_: m√©lange les entr√©es de notre corpus en fonction d'une colonne
  - &rarr; encore ?
  - trier al√©atoirement notre jeu de donn√©e comporte toujours un risque que nos partitions soient mal √©quilibr√©. On peut donc forcer √† avoir une bonne repartition de nos donn√©es en stratifiant sur une colonne en particulier

-horizontal-

<h2 class="r-fit-text">ü§óPartager ses r√©sultatsü§ó</h2>

-vertical-

Dans le cours 3, on a vu la biblioth√®que `datasets` qui permet de charger des corpus de qualit√© directement depuis le *hub* de HuggingFace.

Maintenant qu'on a constitu√© notre propre corpus, on peut nous aussi le partager sur cette plateforme pour que d'autres personnes puissent utiliser notre travail.

-vertical-

On veut donner toutes les informations que l'on a collect√© √† propos de notre corpus aux personnes qui l'utiliseront :

pour √ßa on va renseigner la carte de notre corpus a.k.a. la *dataset card*

-vertical-

## Les cartes des datasets

Les cartes des corpus sont des fichiers YAML

-horizontal-

‚ùì Des questions ‚ùì

üí° Des id√©es üí°

<img class="r-stretch" src="/OutilsTraitementCorpus/slides/img/socrative-qr-code.PNG">

-vertical-

<h2 class="r-fit-text">Le point bonne pratique &rarr; Les _linters_ de code</h2>

Un _linter_ est une implementation de r√®gles de code qui permet de v√©rifier automatiquement la qualit√© de votre code.

En python, les r√®gles de code sont d√©finies par la PEP (Python Extension Proposal) dont on a d√©j√† beaucoup parl√©.

Maintenant, les IDE embarquent des _linters_ directement dans leur interface ce qui leur permet de vous indiquer quand une variable est mal nomm√©e par exemple.

-vertical-

On distingue deux types de _linters_ :

- les _linters_ logiques &rarr; qui corrigent les erreurs de code
- les _linters_ stylistiques &rarr; qui corrigent le code qui ne se conforme pas √† la PEP

    <table class="table table-hover">
    <thead>
    <tr>
    <th>Linter</th>
    <th>Category</th>
    <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
    <td><a href="https://www.pylint.org/">Pylint</a></td>
    <td>Logical &amp; Stylistic</td>
    <td>Checks for errors, tries to enforce a coding standard, looks for code smells</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/pyflakes">PyFlakes</a></td>
    <td>Logical</td>
    <td>Analyzes programs and detects various errors</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/pycodestyle">pycodestyle</a></td>
    <td>Stylistic</td>
    <td>Checks against some of the style conventions in PEP 8</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/pydocstyle">pydocstyle</a></td>
    <td>Stylistic</td>
    <td>Checks compliance with Python docstring conventions</td>
    </tr>
    <tr>
    <td><a href="https://github.com/PyCQA/bandit">Bandit</a></td>
    <td>Logical</td>
    <td>Analyzes code to find common security issues</td>
    </tr>
    <tr>
    <td><a href="http://mypy-lang.org/">MyPy</a></td>
    <td>Logical</td>
    <td>Checks for optionally-enforced static types</td>
    </tr>
    </tbody>
    </table>

-vertical-

Pour aller plus loin, on peut utiliser les _formatters_

Des outils tr√®s utiles pour obtenir du code propre

&rarr; Ils appliquent les conseils des _linters_ directement sur votre code.

On utilise majoritairement `black` pour le formattage de code

et `isort` pour le tri des paquets

ÃÄ```
pip install black
black src/*
``` 

```
pip install isort
python -m isort src/*
```

-vertical-

Pour aller *encore* plus loin :

Si vous ne voulez pas vous emb√™ter √† lancer les commandes `black` et `isort` √† chaque fois que vous faites une modification de votre code (et c'est un bon reflexe : la qualit√© premi√®re de l'informaticien, c'est la flemme !)

Vous pouvez mettre en place un processus automatis√© : 
- avant de commit votre code &rarr; avec des _hooks_
- au moment de tester votre code &rarr; avec l'int√©gration continue (CI)

-vertical-

### Les _hooks_

Les _hooks_ sont des programmes qui se lancent automatiquement √† des moments sp√©cifiques de l'execution de `git`

On peut lancer des programmes √† pleins de moments diff√©rents :
- au moment du commit : `pre-commit`
- pour v√©rifier le format de votre message de commit : `prepare-commit-msg`
- pre-push , ... √† chaque action en fait !

Mettre des [hooks](https://git-scm.com/docs/githooks) en place, c'est tr√®s simple :

-vertical-

On a deux m√©thodes

1. La plus simple : passer par le paquet `pre-commit` et √©crire un fichier YAML de configuration

&rarr; Il contient d√©j√† des [_hooks_ tout pr√™ts √† √™tre utilis√©s](https://pre-commit.com/hooks.html) !

2. La plus propre : Aller modifier le fichier `pre-commit` qu'il y a d√©j√† dans votre repo `.git/hooks`

-vertical-

### Mettre des _hooks_ en place avec `pre-commit`

```
pip install pre-commit
```
```
repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v2.3.0
    hooks:
    -   id: check-yaml
    -   id: end-of-file-fixer
    -   id: trailing-whitespace
-   repo: https://github.com/psf/black
    rev: 22.10.0
    hooks:
    -   id: black
```

-vertical-

### Mettre des _hooks_ en place : la voie classique

1. dans le dossier `hooks` de votre _repo_ git
2. cr√©er un programme executable que vous nommez du nom du hook (`pre-commit` par exemple) avec les commandes que vous voulez faire passer pour votre hook
3. Le rendre executable avec `chmod +x` si n√©cessaire

```
#!/bin/bash

# On r√©cup√®re les fichiers que l'on veut traiter
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep ".jsx\{0,1\}$")

if [[ "$STAGED_FILES" = "" ]]; then
  exit 0
fi

PASS=true

echo "\nlinting:\n"

# Check for black
which black &> /dev/null
if [[ "$?" == 1 ]]; then
  echo "\t\033[41mPlease install black\033[0m"
  exit 1
fi

# Check for isort
which isort &> /dev/null
if [[ "$?" == 1 ]]; then
  echo "\t\033[41mPlease install isort\033[0m"
  exit 1
fi

for FILE in $STAGED_FILES
do
  black "$FILE"
  isort "$FILE"

  if [[ "$?" == 0 ]]; then
    echo "\t\033[32mLinting Passed: $FILE\033[0m"
  else
    echo "\t\033[41mLinting Failed: $FILE\033[0m"
    PASS=false
  fi
done

echo "\nValidation completed!\n"

if ! $PASS; then
  echo "\033[41mCOMMIT FAILED:\033[0m Your commit contains files that should pass black and isort but do not. Please fix the black errors and try again.\n"
  exit 1
else
  echo "\033[42mCOMMIT SUCCEEDED\033[0m\n"
fi

exit $?
``ÃÄ 

-vertical-

### L'Int√©gration Continue

La CI est une bonne pratique de d√©veloppement op√©rationnel (DevOps)

On peut mettre une [CI en place tr√®s facilement avec Gitlab](https://docs.gitlab.com/ee/ci/) en suivant ce [tutoriel](https://docs.gitlab.com/ee/ci/quick_start/#ensure-you-have-runners-available)

ou avec [Github](https://docs.github.com/fr/actions/learn-github-actions/understanding-github-actions)

-vertical-

Des ressources pour les bonnes pratiques de python :
- https://realpython.com/python-code-quality/
- https://realpython.com/python-pep8/

-vertical-

## Un exemple de process automatis√©s pour le TAL

&rarr; Le projet Universal Dependencies

On peut retrouver les differentes √©tapes (_stage_) de la v√©rification des donn√©es sur leur [page](https://universaldependencies.org/validation-rules.html)

<div class="r-fit-text">
  <div>
1. V√©rification du format des donn√©es (CoNLL-U)
2. V√©rification des informations morphosyntaxique (Tous les _tags_ sont des _tag_ CoNLL-U, il ne manque pas de relation)
3. V√©rification des relations (le sens des relations, ...)
4. V√©rification des particularit√©s de langues pour les _tags_
5. V√©rification des particularit√©s de langues pour les _relations_
6. V√©rification que toutes les relations comportent les options voulues 
  </div>
<img src="/OutilsTraitementCorpus/slides/img/g√©n√©rique-sp√©cifique.png">
</div>

-vertical-

## Un exemple de process automatis√©s pour le TAL

&rarr; Le projet Universal Dependencies

La [sortie](http://quest.ms.mff.cuni.cz/udvalidator/cgi-bin/unidep/validation-report.pl) se pr√©sente comme un fichier de log.

-vertical-

1. Split son corpus en train, dev, test
2. Faire la carte de son Dataset
3. Optionnel : si vous pensez que votre corpus est int√©ressant &rarr; Le publier sur huggingFace

N'oubliez pas pour l'√©valuation de votre repo, je vais surtout regarder si vous vous en √™tes tenus aux points bonnes pratiques
- une bonne organisation de votre r√©pertoire de travail
- les commit conventionnels
- les docstrings
- les conventions de nommage